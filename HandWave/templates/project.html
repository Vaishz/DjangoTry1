<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HandWave</title>
    <link rel="icon" type="image/x-icon" href="img/logo.png">
    {% load static %}
    <link rel="stylesheet" href="{% static "project.css" %}">
</head>

<body>
    <header>
        <nav>
        <div class="navigation">
            <div class="logo">
                <a href="/"><img src="{% static 'images/logo.jpg' %}" alt="LOGO"></a>
            </div>
            <ul>
                <li><a href="/">Home</a></li>
                <li class="active"><a href="/project">Project</a></li>
                <li><a href="/reviews">Reviews</a></li>
            </ul>
        </div>
        </nav>
    </header>

    <div class="main">
        <h1>Camera Input Detection</h1>
    
        <select id="cameraSelect" class="button"></select> <!-- Select element for choosing the camera -->
        <div class="video_photo">
            <video id="webcam" autoplay></video>
        </div>
        
        <p id="detectionResult"></p>
    </div>
    
    
    <script>
        const videoElement = document.getElementById("webcam");
        const canvasElement = document.createElement("canvas");
        const detectionResultElement = document.getElementById("detectionResult");
        const cameraSelect = document.getElementById("cameraSelect"); // Select element for choosing the camera
        
        let stream;
        let imageCapture;
        
        async function startCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                // Populate the camera select options
                videoDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${cameraSelect.options.length + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                // Start the camera with the selected device
                const deviceId = cameraSelect.value || videoDevices[0].deviceId;
                stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId } });
                videoElement.srcObject = stream;
                const track = stream.getVideoTracks()[0];
                imageCapture = new ImageCapture(track);
                
                // Automatically capture image after camera starts
                captureImage();
            } catch (error) {
                console.error("Error accessing the camera:", error);
            }
        }
        
        function captureImage() {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasElement.getContext("2d").drawImage(videoElement, 0, 0);
            capturedImageElement.src = canvasElement.toDataURL("image/jpeg");
            capturedImageElement.style.display = "block";
            
            // Call detectHandSign function to detect hand sign
            detectHandSign();
        }
        
        async function detectHandSign() {
            // Here you can implement your hand sign detection logic
            // You can send the captured image to your backend for detection
            
            // For demonstration, let's display a placeholder result
            detectionResultElement.textContent = "Detected: Sign A";
        }
        
        // Event listener for capture button click
        captureButton.addEventListener("click", captureImage);
        
        // Event listener for camera selection change
        cameraSelect.addEventListener("change", async () => {
            // Stop the current stream
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const maxAbsValue = Math.max(...normalizedLandmarks.map(Math.abs));
            const normalizedLandmarksArray = normalizedLandmarks.map(value => value / maxAbsValue);

            return normalizedLandmarksArray;
        }

        main();
    </script>
</body>
</html>
