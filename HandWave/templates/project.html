<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HandWave</title>
    <link rel="icon" type="image/x-icon" href="img/logo.png">
    {% load static %}
    <link rel="stylesheet" href="{% static "project.css" %}">
</head>

<body>
    <header>
        <nav>
        <div class="navigation">
            <div class="logo">
                <a href="/"><img src="{% static 'images/logo.jpg' %}" alt="LOGO"></a>
            </div>
            <ul>
                <li><a href="/">Home</a></li>
                <li class="active"><a href="/project">Project</a></li>
                <li><a href="/reviews">Reviews</a></li>
            </ul>
        </div>
        </nav>
    </header>

    <div class="main">
        <h1>Camera Input Detection</h1>
    
        <select id="cameraSelect" class="button"></select> <!-- Select element for choosing the camera -->
        <div class="video_photo">
            <video id="webcam" autoplay></video>
        </div>
        <button id="captureButton" class="button">Capture Image</button>
        
        
        <p id="detectionResult"></p>
    </div>
    
    
    <script>
        async function main() {
            // Load the TensorFlow.js model
            const model = await tf.loadLayersModel('static/model/model.json');

            // Initialize MediaPipe hands model
            const hands = new Hands();
            await hands.setOptions({
                maxNumHands: 2,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            await hands.initialize();

            const webcamElement = document.getElementById('webcam');
            const canvasElement = document.getElementById('outputCanvas');
            const predictionElement = document.getElementById('prediction');

            // Get webcam feed
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            webcamElement.srcObject = stream;

            hands.onResults(handleHandResults);
            hands.send({ image: webcamElement });

            function handleHandResults(results) {
                const canvasCtx = canvasElement.getContext('2d');
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                        drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });

                        const gesture = recognizeGesture(landmarks);
                        predictionElement.textContent = 'Predicted Gesture: ' + gesture;
                    }
                }
                requestAnimationFrame(() => hands.send({ image: webcamElement }));
            }
        }

        async function recognizeGesture(landmarks) {
            const preProcessedLandmarkList = preprocessLandmarks(landmarks);
            const tfLandmarks = tf.tensor2d([preProcessedLandmarkList]);
            const predictions = model.predict(tfLandmarks).dataSync();
            const alphabet = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            alphabet.push(...Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i)));
            const predictedClassIndex = predictions.indexOf(Math.max(...predictions));
            const predictedGesture = alphabet[predictedClassIndex];
            return predictedGesture;
        }

        function preprocessLandmarks(landmarks) {
            let baseX = 0;
            let baseY = 0;
            const normalizedLandmarks = [];

            for (let i = 0; i < landmarks.length; i++) {
                const landmark = landmarks[i];
                const x = landmark.x;
                const y = landmark.y;

                if (i === 0) {
                    baseX = x;
                    baseY = y;
                }

                const normalizedX = x - baseX;
                const normalizedY = y - baseY;
                normalizedLandmarks.push(normalizedX, normalizedY);
            }

            const maxAbsValue = Math.max(...normalizedLandmarks.map(Math.abs));
            const normalizedLandmarksArray = normalizedLandmarks.map(value => value / maxAbsValue);

            return normalizedLandmarksArray;
        }

        main();
    </script>
</body>
</html>
